leakcanary 工作原理:

可以作为 gc root 的节点
app 中  静态引用，常量引用，栈帧的本地变量(以接口回调实例)
系统的一些东西，比如 输入法....

gc要回收对象是不是能回收，它要去分析某个时间点堆上的快照，如果堆上的对象还在变化
那没有意义，所以gc时候，会暂停其他所有线程(stop the world)，卡顿从这里开始，

内存分配与回收(java中都是自动的,c++/c不是哦)



三个问题:

内存泄露的判定条件是什么?  源码或者debug可以解决(未实践)

内存泄露机制原理

检测到泄露后，轨迹是啥，引用链(源码有debug) (未实践)


1 (父进程)追踪对象(也就是在什么时机去检测这个对象,组件的生命周期方法)
2 (父进程)dump 内存堆到文件(这个文件很大，几十上百M), IdleHandler等待主线程空闲，然后启动一个子线程
  去dump 内存到文件
3 (子进程)分析，根据要检测的对象去获取引用链


1 dump 堆到文件
2 解析文件 (根据具体class 所对应的key去拿调用栈)

重要的方法
RefWatcher.ensureGone(referenc, xxx) {
     // dump 堆 到 文件
   File heapDumpFile = heapDumper.dumpHeap();
   //  解析文件(根据key)

   // 启动	HeapAnalyzerService 在另外一个进程分析
   // 因为这里会产生gc
		

} 

DisplayLeakActivity   android:process=":leakcanary"
RequestStoragePermissionActivity
com.squareup.leakcanary.DisplayLeakService
com.squareup.leakcanary.internal.HeapAnalyzerService
